import { UnpluginOptions, UnpluginContextMeta } from 'unplugin';
import { z } from 'zod';

type NormalizedOptions = z.infer<ReturnType<typeof optionsSchemaFactory>> & Options;
declare const optionsSchemaFactory: (options: Options) => z.ZodObject<{
    apiUrl: z.ZodDefault<z.ZodString>;
    bundleName: z.ZodString;
    dryRun: z.ZodDefault<z.ZodBoolean>;
    retryCount: z.ZodDefault<z.ZodNumber>;
    enableBundleAnalysis: z.ZodDefault<z.ZodBoolean>;
    uploadToken: z.ZodOptional<z.ZodString>;
    uploadOverrides: z.ZodOptional<z.ZodObject<{
        branch: z.ZodOptional<z.ZodString>;
        build: z.ZodOptional<z.ZodString>;
        pr: z.ZodOptional<z.ZodString>;
        sha: z.ZodOptional<z.ZodString>;
        slug: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        branch?: string | undefined;
        build?: string | undefined;
        pr?: string | undefined;
        sha?: string | undefined;
        slug?: string | undefined;
    }, {
        branch?: string | undefined;
        build?: string | undefined;
        pr?: string | undefined;
        sha?: string | undefined;
        slug?: string | undefined;
    }>>;
    debug: z.ZodDefault<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    retryCount: number;
    apiUrl: string;
    bundleName: string;
    dryRun: boolean;
    enableBundleAnalysis: boolean;
    debug: boolean;
    uploadToken?: string | undefined;
    uploadOverrides?: {
        branch?: string | undefined;
        build?: string | undefined;
        pr?: string | undefined;
        sha?: string | undefined;
        slug?: string | undefined;
    } | undefined;
}, {
    bundleName: string;
    apiUrl?: string | undefined;
    dryRun?: boolean | undefined;
    retryCount?: number | undefined;
    enableBundleAnalysis?: boolean | undefined;
    uploadToken?: string | undefined;
    uploadOverrides?: {
        branch?: string | undefined;
        build?: string | undefined;
        pr?: string | undefined;
        sha?: string | undefined;
        slug?: string | undefined;
    } | undefined;
    debug?: boolean | undefined;
}>;
interface NormalizedOptionsFailure {
    success: false;
    errors: string[];
}
interface NormalizedOptionsSuccess {
    success: true;
    options: NormalizedOptions;
}
/**
 * This type represents a union of possible results from the the function.
 *
 * @see {@link normalizeOptions}
 */
type NormalizedOptionsResult = NormalizedOptionsFailure | NormalizedOptionsSuccess;
/**
 * This function is used to normalize the options provided by the user. Validating the options
 * passed by the user, and providing default values for a given set of options if none were
 * provided.
 *
 * @param {Options} userOptions
 * @returns {NormalizedOptionsResult}
 */
declare const normalizeOptions: (userOptions: Options) => NormalizedOptionsResult;
/**
 * This function logs the errors to the console, and will return `shouldExit` if there are errors
 * that we should exit the build process for.
 *
 * @param {NormalizedOptionsFailure} options - The normalized options that failed validation.
 */
declare const handleErrors: (options: NormalizedOptionsFailure) => {
    shouldExit: boolean;
};

declare class Output {
    #private;
    apiUrl: string;
    dryRun: boolean;
    retryCount: number;
    enableBundleAnalysis: boolean;
    uploadToken?: string;
    debug: boolean;
    originalBundleName: string;
    branch?: string;
    build?: string;
    pr?: string;
    sha?: string;
    slug?: string;
    version: string;
    bundler?: {
        name: string;
        version: string;
    };
    outputPath?: string;
    builtAt?: number;
    duration?: number;
    assets?: Asset[];
    chunks?: Chunk[];
    modules?: Module[];
    constructor(userOptions: NormalizedOptions);
    start(): void;
    end(): void;
    lockBundleName(): void;
    unlockBundleName(): void;
    setBundleName(bundleName: string): string;
    get bundleName(): string;
    setPlugin(pluginName: string, pluginVersion: string): {
        name: string;
        version: string;
    } | undefined;
    get plugin(): {
        name: string;
        version: string;
    } | undefined;
    lockPluginDetails(): void;
    unlockPluginDetails(): void;
    write(): Promise<void>;
    bundleStatsToJson(): string;
}

interface Asset {
    name: string;
    size: number;
    normalized: string;
}
interface Chunk {
    id: string;
    uniqueId: string;
    entry: boolean;
    initial: boolean;
    names: string[];
    files: string[];
}
interface Module {
    name: string;
    size?: number;
    chunkUniqueIds: string[];
}
interface BundleAnalysisUploadPluginArgs {
    output: Output;
}
/** Configuration ptions for the Codcove bundler plugin. */
interface Options {
    /**
     * The upload token to use for uploading the bundle analysis information.
     *
     * This value can either be an global upload token or a repo token.
     * - The global upload token can be found under the organization settings page.
     * - The repo token can be found under the repo settings page under the general tab.
     */
    uploadToken?: string;
    /**
     * The api url used to fetch the upload url.
     *
     * Only required if self-hosting codecov.
     *
     * Defaults to `https://api.codecov.io`.
     */
    apiUrl?: string;
    /**
     * The amount of times the upload function will retry to upload bundle analysis information.
     *
     * Defaults to `3`
     */
    retryCount?: number;
    /**
     * When enabled information will not be uploaded to Codecov.
     *
     * Defaults to `false`
     */
    dryRun?: boolean;
    /**
     * The name for the bundle being built.
     *
     * Required for uploading bundle analysis information.
     *
     * The name must match the pattern `/^[\w\d_:/@\.{}\[\]$-]+$/`.
     *
     * Example: `@codecov/rollup-plugin`
     */
    bundleName?: string;
    /**
     * Whether you would like bundle analysis to be enabled. *
     *
     * Defaults to `false`
     */
    enableBundleAnalysis?: boolean;
    /** Override values for passing custom information to API. */
    uploadOverrides?: UploadOverrides;
    /** Option to enable debug logs for the plugin. */
    debug?: boolean;
}
type BundleAnalysisUploadPlugin = (args: BundleAnalysisUploadPluginArgs) => UnpluginOptions & {
    pluginVersion: string;
    version: string;
};
/** A set of overrides that are passed to Codecov. */
interface UploadOverrides {
    /** Specify the branch manually. */
    branch?: string;
    /** Specify the build number manually. */
    build?: string;
    /** Specify the pull request number manually. */
    pr?: string;
    /** Specify the commit SHA manually. */
    sha?: string;
    /** Specify the slug manually. */
    slug?: string;
}
type ProviderEnvs = NodeJS.Dict<string>;
interface ProviderUtilInputs {
    envs: ProviderEnvs;
    args: Options["uploadOverrides"];
}

declare function checkNodeVersion(unpluginMetaContext: UnpluginContextMeta): boolean;

declare function red(msg: string): void;

declare const normalizePath: (path: string, format: string) => string;

export { type Asset, type BundleAnalysisUploadPlugin, type Chunk, type Module, type Options, Output, type ProviderUtilInputs, type UploadOverrides, checkNodeVersion, handleErrors, normalizeOptions, normalizePath, red };
