{"version":3,"file":"index.cjs","sources":["../src/vite-bundle-analysis/viteBundleAnalysisPlugin.ts","../src/index.ts"],"sourcesContent":["import path from \"node:path\";\nimport {\n  normalizePath,\n  type Asset,\n  type Chunk,\n  type Module,\n  type BundleAnalysisUploadPlugin,\n  red,\n} from \"@codecov/bundler-plugin-core\";\n\n// @ts-expect-error this value is being replaced by rollup\nconst PLUGIN_NAME = __PACKAGE_NAME__ as string;\n// @ts-expect-error this value is being replaced by rollup\nconst PLUGIN_VERSION = __PACKAGE_VERSION__ as string;\n\nexport const viteBundleAnalysisPlugin: BundleAnalysisUploadPlugin = ({\n  output,\n}) => ({\n  version: \"1\",\n  name: PLUGIN_NAME,\n  pluginVersion: PLUGIN_VERSION,\n  buildStart: () => {\n    output.start();\n    output.setPlugin(PLUGIN_NAME, PLUGIN_VERSION);\n  },\n  buildEnd: () => {\n    output.end();\n  },\n  writeBundle: async () => {\n    await output.write();\n  },\n  vite: {\n    generateBundle(this, options, bundle) {\n      // TODO - remove this once we hard fail on not having a bundle name\n      // don't need to do anything if the bundle name is not present or empty\n      if (!output.bundleName || output.bundleName === \"\") {\n        red(\"Bundle name is not present or empty. Skipping upload.\");\n        return;\n      }\n\n      output.setBundleName(output.bundleName);\n      // add in bundle name if present\n      if (options.name && options.name !== \"\") {\n        output.setBundleName(`${output.bundleName}-${options.name}`);\n      }\n\n      // append bundle output format to bundle name\n      const format = options.format === \"es\" ? \"esm\" : options.format;\n      output.setBundleName(`${output.bundleName}-${format}`);\n\n      const cwd = process.cwd();\n      const assets: Asset[] = [];\n      const chunks: Chunk[] = [];\n      const moduleByFileName = new Map<string, Module>();\n      const items = Object.values(bundle);\n      const customOptions = {\n        moduleOriginalSize: false,\n        ...options,\n      };\n\n      let assetFormatString = \"\";\n      if (typeof customOptions.assetFileNames === \"string\") {\n        assetFormatString = customOptions.assetFileNames;\n      }\n\n      let chunkFormatString = \"\";\n      if (typeof customOptions.chunkFileNames === \"string\") {\n        chunkFormatString = customOptions.chunkFileNames;\n      }\n\n      let counter = 0;\n      for (const item of items) {\n        if (item?.type === \"asset\") {\n          if (typeof item.source === \"string\") {\n            const fileName = item?.fileName ?? \"\";\n            const size = Buffer.from(item.source).byteLength;\n\n            if (path.extname(fileName) === \".map\") {\n              continue;\n            }\n\n            assets.push({\n              name: fileName,\n              size: size,\n              normalized: normalizePath(fileName, assetFormatString),\n            });\n          } else {\n            const fileName = item?.fileName ?? \"\";\n            const size = item?.source.byteLength;\n\n            if (path.extname(fileName) === \".map\") {\n              continue;\n            }\n\n            assets.push({\n              name: fileName,\n              size: size,\n              normalized: normalizePath(fileName, assetFormatString),\n            });\n          }\n        }\n\n        if (item?.type === \"chunk\") {\n          const chunkId = item?.name ?? \"\";\n          const fileName = item?.fileName ?? \"\";\n          const moduleEntries = Object.entries(item?.modules ?? {});\n          const size = Buffer.from(item?.code).byteLength;\n          const uniqueId = `${counter}-${chunkId}`;\n\n          if (path.extname(fileName) === \".map\") {\n            continue;\n          }\n\n          assets.push({\n            name: fileName,\n            size: size,\n            normalized: normalizePath(fileName, chunkFormatString),\n          });\n\n          chunks.push({\n            id: chunkId,\n            uniqueId: uniqueId,\n            entry: item?.isEntry,\n            initial: item?.isDynamicEntry,\n            files: [fileName],\n            names: [item?.name],\n          });\n\n          for (const [modulePath, moduleInfo] of moduleEntries) {\n            const normalizedModulePath = modulePath.replace(\"\\u0000\", \"\");\n            const relativeModulePath = path.relative(cwd, normalizedModulePath);\n\n            const relativeModulePathWithPrefix = relativeModulePath.match(\n              /^\\.\\./,\n            )\n              ? relativeModulePath\n              : `.${path.sep}${relativeModulePath}`;\n\n            // try to grab module already set in map\n            const moduleEntry = moduleByFileName.get(\n              relativeModulePathWithPrefix,\n            );\n\n            // if the modules exists append chunk ids to the grabbed module\n            // else create a new module and create a new entry in the map\n            if (moduleEntry) {\n              moduleEntry.chunkUniqueIds.push(uniqueId);\n            } else {\n              const size = customOptions.moduleOriginalSize\n                ? moduleInfo.originalLength\n                : moduleInfo.renderedLength;\n\n              const module: Module = {\n                name: relativeModulePathWithPrefix,\n                size: size,\n                chunkUniqueIds: [uniqueId],\n              };\n\n              moduleByFileName.set(relativeModulePathWithPrefix, module);\n            }\n          }\n          counter += 1;\n        }\n      }\n\n      // grab the modules from the map and convert it to an array\n      const modules = Array.from(moduleByFileName.values());\n\n      output.bundler = {\n        name: \"rollup\",\n        version: this.meta.rollupVersion,\n      };\n      output.assets = assets;\n      output.chunks = chunks;\n      output.modules = modules;\n      output.outputPath = options.dir ?? \"\";\n\n      // only output file if running dry run\n      if (output.dryRun) {\n        this.emitFile({\n          type: \"asset\",\n          fileName: `${output.bundleName}-stats.json`,\n          source: output.bundleStatsToJson(),\n        });\n      }\n    },\n  },\n});\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  type UnpluginOptions,\n  createVitePlugin,\n  type VitePlugin,\n} from \"unplugin\";\nimport {\n  type Options,\n  normalizeOptions,\n  checkNodeVersion,\n  Output,\n  handleErrors,\n} from \"@codecov/bundler-plugin-core\";\n\nimport { viteBundleAnalysisPlugin } from \"./vite-bundle-analysis/viteBundleAnalysisPlugin\";\n\nconst codecovVitePluginFactory = createVitePlugin<Options, true>(\n  (userOptions, unpluginMetaContext) => {\n    if (checkNodeVersion(unpluginMetaContext)) {\n      return [];\n    }\n\n    const normalizedOptions = normalizeOptions(userOptions);\n    if (!normalizedOptions.success) {\n      const { shouldExit } = handleErrors(normalizedOptions);\n\n      if (shouldExit) {\n        process.exit(1);\n      }\n      return [];\n    }\n\n    const plugins: UnpluginOptions[] = [];\n    const options = normalizedOptions.options;\n    if (options.enableBundleAnalysis) {\n      const output = new Output(normalizedOptions.options);\n      plugins.push(viteBundleAnalysisPlugin({ output }));\n    }\n\n    return plugins;\n  },\n);\n\n/**\n * Details for the Codecov Vite plugin.\n *\n * @example\n * ```typescript\n * // vite.config.js\n * import { defineConfig } from \"vite\";\n * import { codecovVitePlugin } from \"@codecov/vite-plugin\";\n *\n * export default defineConfig({\n *   plugins: [\n *     // Put the Codecov vite plugin after all other plugins\n *     codecovVitePlugin({\n *       enableBundleAnalysis: true,\n *       bundleName: \"example-vite-bundle\",\n *       uploadToken: process.env.CODECOV_TOKEN,\n *     }),\n *   ],\n * });\n * ```\n *\n * @see {@link @codecov/bundler-plugin-core!Options | Options} for list of options.\n */\nexport const codecovVitePlugin: (options: Options) => VitePlugin<any>[] =\n  codecovVitePluginFactory;\n\n/**\n * Do not use this plugin directly. For internal use only.\n *\n * Used to expose the vite bundle analysis unplugin plugin that can be combined with other plugins\n * to create a single plugin for a given meta-framework.\n *\n * @internal\n */\nexport const _internal_viteBundleAnalysisPlugin = viteBundleAnalysisPlugin;\n"],"names":["PLUGIN_NAME","PLUGIN_VERSION","output","options","bundle","red","format","cwd","assets","chunks","moduleByFileName","items","customOptions","assetFormatString","chunkFormatString","counter","item","fileName","size","path","normalizePath","chunkId","moduleEntries","uniqueId","modulePath","moduleInfo","normalizedModulePath","relativeModulePath","relativeModulePathWithPrefix","moduleEntry","module","modules","codecovVitePluginFactory","createVitePlugin","userOptions","unpluginMetaContext","checkNodeVersion","normalizedOptions","normalizeOptions","shouldExit","handleErrors","plugins","Output","viteBundleAnalysisPlugin"],"mappings":"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"}